#PP1@ project sem 24/25 Petr Florián - Binary Dungeon, a videogame for practicing binary - decimal conversions
import time
from operator import indexOf
from turtledemo.penrose import start

import pygame, random, asyncio, pygame_gui
from sys import exit
from ast import literal_eval
from json import dump
from os import path, listdir
from pathlib import Path
from pygame_aseprite_animation import *

def main_menu() -> None:
    pygame.init()
    pygame.mixer.init()

    #Set screen resolution (imported from settings.json) and caption of the main window
    SCREEN = pygame.display.set_mode((SCREEN_W, SCREEN_H))
    pygame.display.set_caption("Binary Dungeon")

    #load menu music, loop it on set vol and give 10s fade. MUSIC GENERATED BY SUNO.AI  FOR PERSONAL USE BY ME (P. FLORIAN). NOT FOR DISTRIBUTION!!
    pygame.mixer.music.load("Resources/music/menu_music.mp3")
    pygame.mixer.music.set_volume(settingsDict["volume"])
    pygame.mixer.music.play(loops=-1, fade_ms=10000)
    CLICK_SOUND = pygame.mixer.Sound("Resources/sounds/menu_click.mp3")

    #load bg location and transform it to fit resolution
    BACKGROUND = pygame.image.load("Resources/backgrounds/main_menu.jpg")
    BACKGROUND = pygame.transform.scale(BACKGROUND, (SCREEN_W, SCREEN_H))
    MENU_TEXT = get_font(100, True).render("HLAVNÍ NABÍDKA", True, "#D7B498")

    #button pathing & loading
    #buttons handmade by me using https://www.pixilart.com/draw
    button_start = pygame.image.load("Resources/buttons/play.png")
    button_settings = pygame.image.load("Resources/buttons/options.png")
    button_exit = pygame.image.load("Resources/buttons/quit.png")

    button_start_hover = pygame.image.load("Resources/buttons/play_hover.png")
    button_settings_hover = pygame.image.load("Resources/buttons/options_hover.png")
    button_exit_hover = pygame.image.load("Resources/buttons/quit_hover.png")

    # button sizing
    button_size = (200, 70)
    button_size_settings = (300, 70)

    button_start = pygame.transform.scale(button_start, button_size)
    button_settings = pygame.transform.scale(button_settings, button_size_settings)
    button_exit = pygame.transform.scale(button_exit, button_size)

    button_start_hover = pygame.transform.scale(button_start_hover, button_size)
    button_settings_hover = pygame.transform.scale(button_settings_hover, button_size_settings)
    button_exit_hover = pygame.transform.scale(button_exit_hover, button_size)

    # Button positions
    button_start_pos = button_start.get_rect(center=(SCREEN_W / 2, 250))
    button_settings_pos = button_settings.get_rect(center=(SCREEN_W / 2, 350))
    button_exit_pos = button_exit.get_rect(center=(SCREEN_W / 2, 450))

    #the main logic for running the game
    running = True
    while running:
        SCREEN.blit(BACKGROUND, (0,0))
        #draws contents of MENU_TEXT on the position given to "center" attribute - /2 of width and /6 of height loaded form settings
        SCREEN.blit(MENU_TEXT, MENU_TEXT.get_rect(center=((SCREEN_W/2), (SCREEN_H/6))))
        # hover detection
        MOUSE_POS = pygame.mouse.get_pos()
        #hover logic - changing icons for buttons upon hover
        if button_start_pos.collidepoint(MOUSE_POS):
            SCREEN.blit(button_start_hover, button_start_pos)
        else:
            SCREEN.blit(button_start, button_start_pos)

        if button_settings_pos.collidepoint(MOUSE_POS):
            SCREEN.blit(button_settings_hover, button_settings_pos)
        else:
            SCREEN.blit(button_settings, button_settings_pos)

        if button_exit_pos.collidepoint(MOUSE_POS):
            SCREEN.blit(button_exit_hover, button_exit_pos)
        else:
            SCREEN.blit(button_exit, button_exit_pos)

        #scan for clicks
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                if button_start_pos.collidepoint(event.pos):
                    CLICK_SOUND.play()
                    asyncio.run(play_game())
                if button_settings_pos.collidepoint(event.pos):
                    CLICK_SOUND.play()
                    settings_menu(SCREEN, BACKGROUND, settingsDict)
                if button_exit_pos.collidepoint(event.pos):
                    CLICK_SOUND.play()
                    running = False
                    exit()
        # screen refresh
        pygame.display.flip()

    # Quit game after stopping the main loop through calling pygame.QUIT
    pygame.quit()

def settings_menu(screen, background, settings):
    #settings screen. takes these arguments: the screen to render itself on and the settings dict to be changed
    overlay = pygame.Surface((screen.get_width(), screen.get_height()), pygame.SRCALPHA)
    overlay.blit(background, (0,0))

    SETTINGS_TEXT = get_font(100, True).render("NASTAVENÍ", True, "#D7B498")

    # volume slider
    VOLUME_TEXT = get_font(30, True).render("HLASITOST: ", True, "#D7B498")
    volume_bar = pygame.Rect(SCREEN_W/2-150, 230, 300, 20)
    volume_handle = pygame.Rect(SCREEN_W/2-150 + settings["volume"] * 300, 220, 20, 40)

    ui_manager = pygame_gui.UIManager((SCREEN_W, SCREEN_H))
    dropdown = pygame_gui.elements.UIDropDownMenu(options_list=["pixelify.ttf", "NishikiTeki.ttf"], #get_file_names idealne
                                                  starting_option=settingsDict["font"],
                                                  relative_rect=pygame.Rect(SCREEN_W/2-150, 330, 300, 20),
                                                  manager=ui_manager)

    button_back = pygame.image.load("Resources/buttons/back.png")
    button_back_hover = pygame.image.load("Resources/buttons/back_hover.png")

    button_size = (200, 70)
    button_back = pygame.transform.scale(button_back, button_size)
    button_back_hover = pygame.transform.scale(button_back_hover, button_size)
    button_back_pos = button_back.get_rect(center=(SCREEN_W / 2, 450))

    running = True
    while running:
        screen.blit(overlay, (0, 0))
        ui_manager.draw_ui(screen)
        screen.blit(SETTINGS_TEXT, SETTINGS_TEXT.get_rect(center=((SCREEN_W/2), (SCREEN_H/6))))
        screen.blit(VOLUME_TEXT, VOLUME_TEXT.get_rect(center=((SCREEN_W / 2), 200)))

        pygame.draw.rect(screen, "#D7B498", volume_bar, border_radius=8)
        pygame.draw.rect(screen, "#8F5D24", volume_handle, border_radius=8)
        screen.blit(button_back, button_back_pos)

        MOUSE_POS = pygame.mouse.get_pos()

        if button_back_pos.collidepoint(MOUSE_POS):
            screen.blit(button_back_hover, button_back_pos)
        else:
            screen.blit(button_back, button_back_pos)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if button_back_pos.collidepoint(event.pos):
                    pygame.mixer.Sound("Resources/sounds/menu_click.mp3").play()
                    running = False
                elif volume_handle.collidepoint(event.pos):
                    settings["volume"] = (event.pos[0] - volume_bar.x) / volume_bar.width
                    settings["volume"] = max(0, min(1, settings["volume"]))  # Omezit na interval 0–1
                    pygame.mixer.music.set_volume(settings["volume"])
            elif event.type == pygame.MOUSEMOTION and pygame.mouse.get_pressed()[0]:
                if volume_bar.collidepoint(event.pos):
                    settings["volume"] = (event.pos[0] - volume_bar.x) / volume_bar.width
                    settings["volume"] = max(0, min(1, settings["volume"]))
                    pygame.mixer.music.set_volume(settings["volume"])
                    volume_handle.x = volume_bar.x + settings["volume"] * volume_bar.width

            ui_manager.process_events(event)

            if event.type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED and event.ui_element == dropdown:
                selected_font = dropdown.selected_option[0]
                settingsDict["font"] = selected_font

        pygame.display.flip()
        ui_manager.update(60)

    with open("Resources/settings/settings.json", "w") as f:
        dump(settings, f)

async def play_game():

    # set window
    screen = pygame.display.set_mode((SCREEN_W, SCREEN_H))
    pygame.display.set_caption("Binary Dungeon")

    bg_number = 4 #number of backgrounds i currently have ready with the name "BattlegroundX.png" where X is the number
    background = pygame.image.load(f"Resources/backgrounds/Battleground{random.randint(1,bg_number)}.png")
    background = pygame.transform.scale(background, (SCREEN_W, SCREEN_H))

    clock = pygame.time.Clock() #init clock to set FPS
    #create a list for monsters and asynchronous task to spawn monsters
    monsters:list = []
    monster_sprites:list = []
    animations:list = []
    #asynchronous task to spawn monsters in given intervals - higher speed -> more time between spawns
    asyncio.create_task(spawn_monster(monsters, monster_sprites, animations, screen, minSpeed=8, maxSpeed=10))

    monster_speed = 0.8 #(adjust to adjust monster movement speed in pixels per loop update - 1 second)
    #colors
    WHITE = (255, 255, 255)
    BLACK = (0, 0, 0)
    RED = (200, 0, 0)
    GREEN = (0, 200, 0)
    BLUE = (0, 0, 200)

    font = get_font(30) #font hry
    score = 0

    # generate a problem, store returned str values in variables - returns the problem and its correct answer
    current_problem, correct_answer = generate_problem()

    """TIMER_MAX = 6000
    timer = TIMER_MAX"""
    test_animation = Animation('C:/Users/petrf/OneDrive/Plocha/BinaryDungeon/Resources/characters/run/skeletonMage.aseprite')

    testovanaanimace = AnimationManager([test_animation], screen) # test animace
    # user input string init
    user_input = ""

    # gamel oop
    running = True
    while running:
        screen.blit(background, (0,0))
        # check for key input
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    if user_input == correct_answer:
                        score += 1
                        print("zabij nejbliižší monstrum a resetuj časovač")
                        monsters.pop(0)
                        """time.time()"""
                        if monsters:  # if there are monsters in the list (on the screen)
                            current_problem, correct_answer = generate_problem()  # generate a new problem
                    user_input = ""
                elif event.key == pygame.K_BACKSPACE:
                    user_input = user_input[:-1]
                else:
                    try: #try except only accepts numeric values (values that can be processed with int())
                        int(event.unicode)
                        user_input += event.unicode
                    except:
                        continue

        # move and draw monsters cycle, end game condition
        for i, monster in enumerate(monsters):
            monster["x"] += monster_speed  #move monster on x-axis (adjust to adjust monster movement speed)
            """pygame.draw.circle(screen, (200, 0, 0), (monster["x"], monster["y"]), 20)"""
            """ tohle appendovani musim udelat jindy - nesmim opakovat! update by mel byt snad v pohode
            animations.append(AnimationManager([monster_sprites[monsters.index(monster)]], screen))"""
            animations[i].update_self(monster["x"], monster["y"])

            #end game if monster reaches player
            if monster["x"] >= SCREEN_W-450:
                print("GAME OVER OBRAZOVKA")
                running = False
                game_over(screen, score)

        """# timer - WIP
        timer -= 1
        if timer <= 0:
            running = False  #ends game after time runs out"""

        # render shi
        score_text = font.render(f"Skóre: {score}", True, WHITE)
        screen.blit(score_text, (10, 10))

        problem_text = font.render(current_problem, True, WHITE)
        screen.blit(problem_text, (SCREEN_W // 2 - problem_text.get_width() // 2, SCREEN_H // 3))

        input_text = font.render(user_input, True, GREEN if user_input == correct_answer else WHITE)
        screen.blit(input_text, (SCREEN_W // 2 - input_text.get_width() // 2, SCREEN_H // 2))

        player_wall = pygame.draw.rect(screen,(0,255,255), (SCREEN_W-400, 0, 40, SCREEN_H))

        """# time countdown bar
        pygame.draw.rect(screen, RED, (50, 50, (SCREEN_W - 100) * (timer / TIMER_MAX), 20))
        pygame.draw.rect(screen, WHITE, (50, 50, SCREEN_W - 100, 20), 2)"""

        print(f"DEBUG (play_game) - monsters: {monsters}")
        print(f"DEBUG (play_game) - sprites:  {monster_sprites}")

        pygame.display.flip()
        await asyncio.sleep(0) # yield process to the event loop
        clock.tick(60) # set FPS to 60 - stable game time speed

async def generate_monster(): #create and save to a FIFO collection
    return {
        "x": -50,
        "y": random.randint(int(SCREEN_H/2 + 100), SCREEN_H - 100)
        #"speed": random.uniform(0.8, 1.2)
        #if correct guess access this monster in a list (FIFO) and delete. if not on time, K.O.
    }

def choose_monster_sprite():
    runSpriteSkeletonTuple = (
        'skeletonMage.aseprite',
        'skeleton.aseprite',
        'skeletonRogue.aseprite',
        'skeletonWarrior.aseprite'
    )
    runSpriteOrcTuple = (
        'orcShaman.aseprite',
        'orc.aseprite',
        'orcRogue.aseprite',
        'orcWarrior.aseprite'
    )
    runTuple = (runSpriteSkeletonTuple, runSpriteOrcTuple)
    return random.choice(random.choice(runTuple))

def scaled_animation(modifier:float = 1.5): #allow custom animation scaling (default size: 64x64x32)
    animace = Animation(charactersDir + 'run/' + choose_monster_sprite())
    scaled_frames = []
    for frame in animace.animation_frames:
        scaled =pygame.transform.scale(frame, (frame.get_width()*modifier, frame.get_height()*modifier))
        scaled_frames.append(scaled)
    animace.animation_frames = scaled_frames
    return animace

async def spawn_monster(monsters:list, monster_sprites:list, animations:list, screen, minSpeed:float=8, maxSpeed:float=10):
    while True:
        await asyncio.sleep(random.uniform(minSpeed, maxSpeed)) #higher number -> more time between spawns)
        # generate monster
        monster = await generate_monster()
        monsters.append(monster)
        animations.append(AnimationManager([scaled_animation()], screen))
        print("DEBUG - spawn_monster(): PRISERA VYGENEROVANA! - ", path.basename(str(monsters[0])))

def generate_problem(minRange: int = 1, maxRange: int = 64, mode: int =0):
    #Create a problem to solve
    match mode:
    #give an option to pass an argument and choose only one direction of conversion
        case 1:
            mode = "dec_to_bin"
        case 2:
            mode = "bin_to_dec"
        case _:
            mode = random.choice(["bin_to_dec", "dec_to_bin"])

    if mode == "bin_to_dec":
        binary_number = format(random.randint(minRange, maxRange), 'b') #converts generated int to binary of bit length dependent on the number
        current_problem = f"Převeď {binary_number} do desítkové soustavy"
        correct_answer = str(int(binary_number, 2))
    elif mode == "dec_to_bin":
        decimal_number = random.randint(minRange, maxRange)
        current_problem = f"Převeď {decimal_number} do dvojkové soustavy"
        correct_answer = format(decimal_number, 'b')
    else:
        raise Exception("function generate_problem() received an invalid \'mode\' argument. Argument should be an integer value.")

    return current_problem, correct_answer

def game_over(screen, score):
    pygame.font.init()
    font = get_font(50)
    small_font = get_font(36)

    game_over_text = font.render("Zemřel jsi!", True, (255, 0, 0))
    score_text = font.render(f"Skóre: {score}", True, (255, 255, 255))
    menu_text = small_font.render("Zmáčkni M pro návrat do hlavního menu", True, (255, 255, 255))

    screen.fill((255, 0, 0))
    screen.blit(game_over_text, (screen.get_width() // 2 - game_over_text.get_width() // 2, 150))
    screen.blit(score_text, (screen.get_width() // 2 - score_text.get_width() // 2, 220))
    screen.blit(menu_text, (screen.get_width() // 2 - menu_text.get_width() // 2, 300))

    pygame.display.flip()

    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_m:
                    waiting = False

def load_settings():
    #Read the .json file dedicated to various game settings, store the file in a string, convert the string to a dictionary and return the dictionary
    """f = open("Resources/settings/settings.json", "r")
    settingsString = ""
    for char in f:
        settingsString = settingsString + char"""
    with open("Resources/settings/settings.json", "r") as f:
        settingsString = f.read()
    return literal_eval(settingsString) #converts type string to type dictionary

def get_font(size:int, interface = False):
    #load the font from settings and return it with the specified size from the parameter
    if interface:
        return pygame.font.Font(f"Resources/fonts/{settingsDict["interface_font"]}",size)
    return pygame.font.Font(f"Resources/fonts/{settingsDict["font"]}",size)

def get_file_names(folder_path, format = ".ttf"):
    return [f.name for f in Path(folder_path).glob(format)]

if __name__ == "__main__":
    #GLOBAL VARIABLES
    settingsDict = load_settings()
    SCREEN_W = settingsDict["resolution_w"]
    SCREEN_H = settingsDict["resolution_h"]
    charactersDir = str(path.dirname(__file__)) + "/Resources/characters/"
    animations:list = [] #musi byt zde - v play neappenduje z spawn fce!

    #temp shi DEBUG
    print(f"DEBUG - Settings file contents:\n{settingsDict}")
    main_menu()
    """sprites from: https://anokolisa.itch.io/dungeon-crawler-pixel-art-asset-pack"""